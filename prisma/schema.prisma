// This is your Prisma schema file
// learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================
// MODELOS PRINCIPALES
// =============================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model User {
  id            String     @id @default(cuid())
  name          String
  lastName      String?
  email         String     @unique
  password      String?
  emailVerified DateTime?
  roles         UserRole[] @default([GUEST])
  status        UserStatus @default(ACTIVE)
  timezone      String     @default("America/Lima")
  image         String?
  bio           String? // Datos del profesor integrados
  permissions   String[] // Permisos para administradores
  teamBadge     TeamBadge? // Badge del equipo para chat flotante
  accounts      Account[]
  teacherRankId String?

  // Relaciones comunes
  createdCourses        Course[]
  createdActivities     Activity[]         @relation("ActivityCreator")
  enrollments           Enrollment[]
  enrollmentsAsTeacher  Enrollment[]       @relation("EnrollmentTeacher")
  completedContents     UserContent[]
  viewedResources       ResourceView[]
  savedResources        UserResource[]
  activities            UserActivity[]
  attendances           ClassAttendance[]
  teacherAttendances    TeacherAttendance[] @relation("TeacherAttendances")

  // Relaciones del sistema de clases
  bookingsAsStudent   ClassBooking[]        @relation("StudentBookings")
  bookingsAsTeacher   ClassBooking[]        @relation("TeacherBookings")
  classSchedules      ClassSchedule[]       @relation("TeacherSchedules")
  studentCredits      StudentCredit[]
  classCredits        ClassCredit[]
  teacherIncentives   TeacherIncentive[]
  teacherAvailability TeacherAvailability[]

  // Relación de profesor
  teacherRank TeacherRank? @relation(fields: [teacherRankId], references: [id])

  // Relación de racha de usuario
  userStreak UserStreak?

  // Relaciones del sistema de vidas y recompensas
  userLives          UserLives?
  userRewards        UserRewards?
  rewardTransactions RewardTransaction[]

  // Relaciones comerciales
  invoices             Invoice[]
  productPurchases     ProductPurchase[]
  scheduleSlotBookings ProductScheduleSlot[] @relation("ScheduleSlotBookings")
  subscriptions        Subscription[]

  // Relaciones del sistema de créditos virtuales
  userCreditBalance   UserCreditBalance?
  creditTransactions  CreditTransaction[]
  creditPackagePurchases CreditPackagePurchase[]

  // Relaciones de videollamadas JaaS
  teacherCalls VideoCall[] @relation("TeacherCalls")
  studentCalls VideoCall[] @relation("StudentCalls")

  // Relaciones de chat flotante
  conversationsAsParticipant ConversationParticipant[]
  sentFloatingMessages       FloatingChatMessage[]     @relation("SentFloatingMessages")
  sentMeetingMessages        MeetingMessage[]          @relation("SentMeetingMessages")

  // Relaciones de exámenes
  createdExams     Exam[]           @relation("ExamCreator")
  examAttempts     ExamAttempt[]    @relation("ExamAttempts")
  examAssignments  ExamAssignment[] @relation("ExamAssignments")
  assignedExams    ExamAssignment[] @relation("ExamAssigner")
  reviewedAnswers  ExamAnswer[]     @relation("ExamReviewer")

  // Relaciones de respuestas de bloques en lecciones
  blockResponses   BlockResponse[]
  aiGradingUsage   AIGradingUsage[]

  // Relación de cursos que puede enseñar (para profesores)
  teachableCourses TeacherCourse[]

  // Configuración de pagos para profesores (JSON string)
  paymentSettings String?

  // Relaciones de biblioteca de recursos
  libraryResources    LibraryResource[]     @relation("LibraryAuthor")
  libraryLikes        LibraryResourceLike[] @relation("LibraryLikes")
  librarySaves        LibraryResourceSave[] @relation("LibrarySaves")

  // Relaciones de administración de archivos
  uploadedFiles    FileAsset[]       @relation("FileUploader")
  fileUsageLogs    FileUsageLog[]    @relation("FileUser")
  createdFolders   FileFolder[]      @relation("FolderCreator")

  // Relaciones de lecciones personalizadas
  personalizedLessons        Lesson[] @relation("StudentLessons")
  createdPersonalizedLessons Lesson[] @relation("TeacherCreatedLessons")

  // Relaciones de notificaciones
  notifications         Notification[]

  // API Keys para acceso programático
  apiKeys               ApiKey[]

  // Órdenes pendientes de pago
  pendingOrders         PendingOrder[]

  // Cupones restringidos a este usuario
  restrictedCoupons     Coupon[] @relation("UserCoupons")

  // Relaciones para app móvil
  deviceTokens          DeviceToken[]
  refreshTokens         RefreshToken[]

  // Confirmaciones de pago de profesores
  paymentConfirmations  TeacherPaymentConfirmation[]

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  @@index([roles])
  @@index([teacherRankId])
}

model ApiKey {
  id          String    @id @default(cuid())
  name        String    // Nombre descriptivo de la API Key
  key         String    @unique // Hash de la API Key
  prefix      String    // Prefijo visible (ej: "lw_live_abc...")
  userId      String
  scopes      String[]  @default(["lessons:read", "lessons:write"]) // Permisos
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  isActive    Boolean   @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([key])
  @@index([userId])
  @@map("api_keys")
}

model UserStreak {
  userId           String    @id
  currentStreak    Int       @default(0)
  longestStreak    Int       @default(0)
  lastActivityDate DateTime?
  updatedAt        DateTime  @updatedAt

  // Relación con User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_streaks")
}

model UserLives {
  userId           String   @id
  currentLives     Int      @default(5) // Máximo 5 vidas
  maxLives         Int      @default(5)
  lastRechargeTime DateTime @default(now())
  rechargeRate     Int      @default(30) // Minutos para recargar 1 vida
  updatedAt        DateTime @updatedAt

  // Relación con User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_lives")
}

model UserRewards {
  userId       String   @id
  totalPoints  Int      @default(0)
  spentPoints  Int      @default(0)
  currentLevel Int      @default(1)
  updatedAt    DateTime @updatedAt

  // Relación con User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_rewards")
}

model RewardTransaction {
  id          String     @id @default(cuid())
  userId      String
  type        RewardType
  amount      Int // Puntos ganados o gastados
  description String
  metadata    Json? // Información adicional sobre la transacción
  createdAt   DateTime   @default(now())

  // Relación con User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("reward_transactions")
}

// =============================================
// MODELOS DE CRÉDITOS VIRTUALES
// =============================================

model UserCreditBalance {
  userId           String   @id
  totalCredits     Int      @default(0) // Total de créditos comprados
  availableCredits Int      @default(0) // Créditos disponibles para gastar
  spentCredits     Int      @default(0) // Créditos gastados
  bonusCredits     Int      @default(0) // Créditos de bonificación
  updatedAt        DateTime @updatedAt

  // Relación con User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_credit_balances")
}

model CreditPackage {
  id               String  @id @default(cuid())
  name             String // "Paquete Básico", "Paquete Premium", etc.
  description      String?
  credits          Int // Cantidad de créditos que otorga
  price            Float // Precio en dinero real
  bonusCredits     Int     @default(0) // Créditos extra de bonificación
  isActive         Boolean @default(true)
  isPopular        Boolean @default(false)
  sortOrder        Int     @default(0)
  image            String?
  
  // Relaciones
  purchases CreditPackagePurchase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("credit_packages")
}

model CreditPackagePurchase {
  id              String        @id @default(cuid())
  userId          String
  packageId       String
  invoiceId       String
  creditsReceived Int // Créditos recibidos (incluye bonus)
  status          PurchaseStatus @default(CONFIRMED)
  purchaseDate    DateTime      @default(now())

  // Relaciones
  user    User          @relation(fields: [userId], references: [id])
  package CreditPackage @relation(fields: [packageId], references: [id])
  invoice Invoice       @relation(fields: [invoiceId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([packageId])
  @@index([invoiceId])
  @@map("credit_package_purchases")
}

model CreditTransaction {
  id                String                @id @default(cuid())
  userId            String
  transactionType   CreditTransactionType
  amount            Int // Créditos (positivo = ganado, negativo = gastado)
  balanceBefore     Int // Balance antes de la transacción
  balanceAfter      Int // Balance después de la transacción
  description       String
  relatedEntityId   String? // ID del producto, plan, etc. relacionado
  relatedEntityType String? // "product", "plan", "course", etc.
  metadata          Json? // Información adicional
  createdAt         DateTime              @default(now())

  // Relación con User
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([transactionType])
  @@index([createdAt])
  @@map("credit_transactions")
}

// =============================================
// MODELOS DE CONTENIDO EDUCATIVO
// =============================================

model Course {
  id            String  @id @default(cuid())
  title         String
  description   String
  language      String
  level         String
  isPublished   Boolean @default(false)
  createdById   String
  classDuration Int     @default(40) // Duración de cada clase en minutos (30, 40, 60, 90)
  image         String? // Imagen del curso para Course Builder
  defaultPaymentPerClass Float? // Pago por defecto por clase para profesores (en moneda local)
  
  // Configuración de contenido personalizado
  isPersonalized Boolean @default(false) // Si usa lecciones personalizadas por estudiante
  isSynchronous  Boolean @default(false) // Si es un curso sincrónico (requiere clases en vivo con horario)

  // Relaciones
  createdBy        User            @relation(fields: [createdById], references: [id])
  modules          Module[]
  enrollments      Enrollment[]
  products         Product[]
  plans            Plan[]
  exams            Exam[]
  teacherCourses   TeacherCourse[] // Profesores que pueden enseñar este curso
  planPricing      PlanPricing[]   // Precios de planes que apuntan a este curso

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([createdById])
  @@map("courses")
}

model Module {
  id          String  @id @default(cuid())
  title       String
  description String?
  level       String  @default("A1")
  order       Int     @default(0)
  isPublished Boolean @default(false)
  courseId    String
  objectives  String? // Objetivos del módulo para Course Builder

  // Relaciones
  course     Course           @relation(fields: [courseId], references: [id], onDelete: Cascade)
  lessons    Lesson[]
  activities ModuleActivity[]
  exams      Exam[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([courseId])
  @@map("modules")
}

model Lesson {
  id          String  @id @default(cuid())
  title       String
  description String  @default("")
  order       Int     @default(0)
  moduleId    String? // Opcional: null para lecciones personalizadas
  duration    Int     @default(30) // Duración estimada de la lección en minutos
  isPublished Boolean @default(false) // Estado de publicación de la lección
  
  // Campos para el diseño del reproductor
  videoUrl      String? // URL del video/audio principal
  summary       String? // Subtítulo o resumen corto
  transcription String? // Transcripción del audio/video

  // Campos para lecciones personalizadas (null para lecciones de curso)
  studentId    String? // El estudiante dueño de esta lección (si es personalizada)
  teacherId    String? // El profesor que la creó (si es personalizada)
  enrollmentId String? // La inscripción asociada (si es personalizada)

  // Relaciones
  module     Module?          @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  contents   Content[]
  activities LessonActivity[]
  exams      Exam[]
  
  // Relaciones para lecciones personalizadas
  student    User?            @relation("StudentLessons", fields: [studentId], references: [id], onDelete: Cascade)
  teacher    User?            @relation("TeacherCreatedLessons", fields: [teacherId], references: [id])
  enrollment Enrollment?      @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  progress   LessonProgress?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([moduleId])
  @@index([studentId])
  @@index([teacherId])
  @@index([enrollmentId])
  @@map("lessons")
}

model LessonProgress {
  id        String    @id @default(cuid())
  lessonId  String    @unique
  studentId String
  completed Boolean   @default(false)
  percentage Float    @default(0)
  lastAccessed DateTime?
  completedAt  DateTime?

  // Relaciones
  lesson Lesson @relation(fields: [lessonId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studentId])
  @@map("lesson_progress")
}

model Content {
  id          String      @id @default(cuid())
  title       String
  description String?     // Hecho opcional
  order       Int         @default(0)
  contentType ContentType
  lessonId    String
  parentId    String?     // Para estructura recursiva (Tabs, Contenedores)
  data        Json?       // Datos flexibles del contenido (Video URL, Texto HTML, Preguntas Quiz, etc.)

  // Relaciones
  lesson         Lesson          @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  parent         Content?        @relation("ContentHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children       Content[]       @relation("ContentHierarchy")
  userProgress   UserContent[]
  blockResponses BlockResponse[]

  // Relaciones específicas (Mantenidas por compatibilidad temporal, pero se migrarán a `data`)
  grammarCard          GrammarCard?
  leveledText          LeveledText?
  thematicGlossary     ThematicGlossary?
  downloadableResource DownloadableResource?
  activity             Activity?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([lessonId])
  @@index([parentId])
  @@map("contents")
}

model Activity {
  id           String       @id @default(cuid())
  contentId    String?      @unique // Opcional: puede existir independientemente
  title        String
  description  String
  activityType ActivityType
  level        Int          @default(1)
  points       Int          @default(10)
  duration     Int          @default(5) // en minutos
  activityData Json // Estructura de la actividad
  steps        Json // Pasos de la actividad con su estructura tipada
  questions    Json? // Preguntas, opciones y respuestas
  timeLimit    Int? // Tiempo límite en segundos
  createdById  String
  isPublished  Boolean      @default(false)

  // Relaciones
  content      Content?         @relation(fields: [contentId], references: [id])
  createdBy    User             @relation("ActivityCreator", fields: [createdById], references: [id])
  modules      ModuleActivity[]
  lessons      LessonActivity[]
  userProgress UserActivity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([contentId])
  @@map("activities")
}

// Tipos específicos de contenido

model GrammarCard {
  id            String  @id @default(cuid())
  contentId     String  @unique
  level         String
  grammarPoints Json // Puntos gramaticales con ejemplos
  explanations  Json // Explicaciones detalladas
  notes         String?

  // Relación
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("grammar_cards")
}

model LeveledText {
  id          String  @id @default(cuid())
  contentId   String  @unique
  level       String
  textContent String // Texto completo
  translation String? // Traducción opcional
  audioUrl    String? // URL al archivo de audio
  vocabulary  Json? // Palabras destacadas
  exercises   Json? // Ejercicios de comprensión

  // Relación
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("leveled_texts")
}

model ThematicGlossary {
  id         String @id @default(cuid())
  contentId  String @unique
  theme      String // Tema del glosario
  level      String
  terms      Json // Términos con definiciones
  categories Json? // Categorías para términos

  // Relación
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("thematic_glossaries")
}

model DownloadableResource {
  id           String       @id @default(cuid())
  contentId    String       @unique
  resourceType ResourceType
  fileUrl      String // URL al archivo
  fileSize     Int // Tamaño en bytes
  fileFormat   String // PDF, DOCX, etc.
  previewUrl   String? // URL a vista previa
  pages        Int? // Número de páginas
  downloads    Int          @default(0)

  // Relaciones
  content   Content        @relation(fields: [contentId], references: [id], onDelete: Cascade)
  userSaves UserResource[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("downloadable_resources")
}

// =============================================
// MODELOS DE SEGUIMIENTO DE PROGRESO
// =============================================

model UserContent {
  id           String    @id @default(cuid())
  userId       String
  contentId    String
  completed    Boolean   @default(false)
  percentage   Float     @default(0)
  lastAccessed DateTime?

  // Relaciones
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, contentId])
  @@index([userId])
  @@index([contentId])
  @@map("user_contents")
}

model BlockResponse {
  id          String   @id @default(cuid())
  userId      String
  contentId   String
  blockId     String
  blockType   String
  response    Json
  score       Float?
  maxScore    Float?
  isCorrect   Boolean?
  feedback    String?  @db.Text
  gradedBy    String?
  gradedAt    DateTime?
  submittedAt DateTime @default(now())
  
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  content Content @relation(fields: [contentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, contentId, blockId])
  @@index([userId])
  @@index([contentId])
  @@index([blockId])
  @@map("block_responses")
}

model AIGradingUsage {
  id          String   @id @default(cuid())
  userId      String
  usageType   String   // "essay_lesson", "essay_exam", "recording"
  entityId    String?  // ID del bloque, pregunta, etc.
  entityType  String?  // "block", "exam_question"
  tokensUsed  Int?     // Tokens consumidos (opcional para tracking)
  periodStart DateTime // Inicio del período de facturación
  periodEnd   DateTime // Fin del período de facturación
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([userId, usageType, periodStart, periodEnd])
  @@map("ai_grading_usage")
}

model ProctorEvent {
  id          String   @id @default(cuid())
  attemptId   String
  eventType   String   // "tab_switch", "fullscreen_exit", "copy_attempt", "paste_attempt", "right_click", "window_blur"
  severity    String   @default("warning") // "info", "warning", "critical"
  description String?
  metadata    Json?    // Datos adicionales del evento
  timestamp   DateTime @default(now())
  
  attempt ExamAttempt @relation(fields: [attemptId], references: [id], onDelete: Cascade)

  @@index([attemptId])
  @@index([attemptId, eventType])
  @@map("proctor_events")
}

model UserActivity {
  userId        String
  activityId    String
  status        ActivityStatus @default(ASSIGNED)
  score         Float?
  answers       Json? // Respuestas dadas
  attempts      Int            @default(0)
  completedAt   DateTime?
  lastAttemptAt DateTime?
  assignedBy    String?
  assignedAt    DateTime       @default(now())

  // Relaciones
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@id([userId, activityId])
  @@index([userId])
  @@index([activityId])
  @@map("user_activities")
}

model ResourceView {
  id        String   @id @default(cuid())
  userId    String
  contentId String
  viewedAt  DateTime @default(now())

  // Relación
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([contentId])
  @@map("resource_views")
}

model UserResource {
  id         String   @id @default(cuid())
  userId     String
  resourceId String
  savedAt    DateTime @default(now())

  // Relaciones
  user     User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  resource DownloadableResource @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  @@unique([userId, resourceId])
  @@index([userId])
  @@index([resourceId])
  @@map("user_resources")
}

model Enrollment {
  id               String           @id @default(cuid())
  studentId        String
  courseId         String
  academicPeriodId String
  teacherId        String?          // Profesor responsable de esta inscripción
  status           EnrollmentStatus @default(ACTIVE)
  progress         Float            @default(0)
  enrollmentDate   DateTime         @default(now())
  lastAccessed     DateTime?
  classesTotal     Int              @default(8) // Total de clases en el paquete
  classesAttended  Int              @default(0) // Clases asistidas
  classesMissed    Int              @default(0) // Clases perdidas
  
  // Campos para inscripción manual vs automática
  enrollmentType   EnrollmentType   @default(AUTOMATIC) // Tipo de inscripción
  enrolledBy       String?          // ID del admin que inscribió manualmente (null si fue automática)
  notes            String?          // Notas adicionales de la inscripción
  
  // Campos para reagendamiento de clases
  reschedulesUsed  Int              @default(0) // Cantidad de reagendamientos usados en este período

  // Relaciones
  student        User              @relation(fields: [studentId], references: [id], onDelete: Cascade)
  course         Course            @relation(fields: [courseId], references: [id], onDelete: Cascade)
  academicPeriod AcademicPeriod    @relation(fields: [academicPeriodId], references: [id], onDelete: Restrict)
  teacher        User?             @relation("EnrollmentTeacher", fields: [teacherId], references: [id], onDelete: SetNull)
  purchases      ProductPurchase[]
  bookings       ClassBooking[]    // Clases programadas para esta inscripción
  attendances    ClassAttendance[] // Asistencias para esta inscripción
  schedules      ClassSchedule[]   // Horarios recurrentes para esta inscripción
  personalizedLessons Lesson[]     // Lecciones personalizadas para esta inscripción

  @@unique([studentId, courseId, academicPeriodId])
  @@index([studentId])
  @@index([courseId])
  @@index([academicPeriodId])
  @@index([teacherId])
  @@map("enrollments")
}

// =============================================
// MODELOS DE RELACIÓN (TABLAS PIVOTE)
// =============================================

model ModuleActivity {
  moduleId   String
  activityId String
  order      Int    @default(0)

  // Relaciones
  module   Module   @relation(fields: [moduleId], references: [id], onDelete: Cascade)
  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@id([moduleId, activityId])
  @@index([moduleId])
  @@index([activityId])
  @@map("module_activities")
}

model LessonActivity {
  lessonId   String
  activityId String
  order      Int    @default(0)

  // Relaciones
  lesson   Lesson   @relation(fields: [lessonId], references: [id], onDelete: Cascade)
  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@id([lessonId, activityId])
  @@index([lessonId])
  @@index([activityId])
  @@map("lesson_activities")
}

model TeacherCourse {
  teacherId       String
  courseId        String
  paymentPerClass Float?  // Pago por clase para este profesor en este curso (en la moneda local)

  // Relaciones
  teacher User   @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  course  Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@id([teacherId, courseId])
  @@index([teacherId])
  @@index([courseId])
  @@map("teacher_courses")
}

// =============================================
// MODELOS DE CLASES Y PERÍODOS ACADÉMICOS
// =============================================

model ClassBooking {
  id           String        @id @default(cuid())
  studentId    String
  teacherId    String
  enrollmentId String
  day          String // YYYY-MM-DD
  timeSlot     String // HH:MM-HH:MM
  status       BookingStatus @default(CONFIRMED)
  notes        String?
  reminderSent Boolean       @default(false)
  feedbackId   String?
  cancelledAt  DateTime?
  cancelledBy  String?
  completedAt  DateTime?
  creditId     String?
  isPayable    Boolean       @default(false) // Marcar manualmente como válida para pago al profesor

  // Relaciones
  student            User                @relation("StudentBookings", fields: [studentId], references: [id])
  teacher            User                @relation("TeacherBookings", fields: [teacherId], references: [id])
  enrollment         Enrollment          @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  studentCredit      StudentCredit?      @relation(fields: [creditId], references: [id])
  attendances        ClassAttendance[]
  teacherAttendances TeacherAttendance[]
  videoCalls         VideoCall[]
  meetingMessages    MeetingMessage[]
  whiteboardData     WhiteboardData?
  recordings         ClassRecording[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([teacherId, day, timeSlot])
  @@index([studentId])
  @@index([teacherId])
  @@index([enrollmentId])
  @@map("class_bookings")
}

model Season {
  id          String   @id @default(cuid())
  name        String
  year        Int
  startDate   DateTime
  endDate     DateTime
  description String?

  // Relaciones
  periods AcademicPeriod[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, year])
  @@index([year])
  @@map("seasons")
}

model AcademicPeriod {
  id            String   @id @default(cuid())
  name          String
  startDate     DateTime
  endDate       DateTime
  seasonId      String
  isSpecialWeek Boolean  @default(false)
  isActive      Boolean  @default(false)

  // Relaciones
  season            Season             @relation(fields: [seasonId], references: [id])
  classCredits      ClassCredit[]
  teacherIncentives TeacherIncentive[]
  enrollments       Enrollment[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([seasonId])
  @@index([startDate, endDate])
  @@map("academic_periods")
}

model ClassSchedule {
  id           String @id @default(cuid())
  enrollmentId String
  teacherId    String
  dayOfWeek    Int // 0-6, 0 es domingo
  startTime    String // HH:MM
  endTime      String // HH:MM

  // Relaciones
  enrollment Enrollment @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)
  teacher    User       @relation("TeacherSchedules", fields: [teacherId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([enrollmentId, dayOfWeek, startTime])
  @@index([teacherId, dayOfWeek])
  @@map("class_schedules")
}

model ClassCredit {
  id             String   @id @default(cuid())
  studentId      String
  originPeriodId String
  targetPeriodId String?
  creditAmount   Int      @default(1)
  isUsed         Boolean  @default(false)
  expiryDate     DateTime

  // Relaciones
  student      User           @relation(fields: [studentId], references: [id], onDelete: Cascade)
  originPeriod AcademicPeriod @relation(fields: [originPeriodId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studentId])
  @@index([originPeriodId])
  @@index([targetPeriodId])
  @@map("class_credits")
}

model StudentCredit {
  id         String   @id @default(cuid())
  studentId  String
  amount     Int      @default(1)
  source     String // rollover, perfect_attendance, etc.
  isUsed     Boolean  @default(false)
  usedFor    String? // class, discount, materials, etc.
  expiryDate DateTime

  // Relaciones
  student  User           @relation(fields: [studentId], references: [id])
  bookings ClassBooking[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studentId])
  @@map("student_credits")
}

model TeacherIncentive {
  id          String    @id @default(cuid())
  teacherId   String
  periodId    String
  type        String // retention, perfect_attendance, etc.
  percentage  Float
  baseAmount  Float
  bonusAmount Float
  paid        Boolean   @default(false)
  paidAt      DateTime?

  // Relaciones
  teacher User           @relation(fields: [teacherId], references: [id])
  period  AcademicPeriod @relation(fields: [periodId], references: [id])

  createdAt DateTime @default(now())

  @@index([teacherId, periodId])
  @@map("teacher_incentives")
}

model TeacherRank {
  id                String @id @default(cuid())
  name              String // Basic, Certified, Senior, Master
  level             Int // 1, 2, 3, 4
  rateMultiplier    Float // 1.0, 1.05, 1.1, 1.15
  requirementHours  Int
  requirementRating Float
  requirementTime   Int // Meses mínimos en plataforma

  // Relaciones
  teachers User[]

  @@map("teacher_ranks")
}

model TeacherAvailability {
  id        String @id @default(cuid())
  userId    String
  day       String // Día semana o fecha específica YYYY-MM-DD
  startTime String // HH:MM
  endTime   String // HH:MM

  // Relación
  user User @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, day, startTime, endTime])
  @@index([userId, day])
  @@map("teacher_availability")
}

model ClassAttendance {
  id           String           @id @default(cuid())
  classId      String
  studentId    String
  enrollmentId String
  status       AttendanceStatus @default(PRESENT)
  timestamp    DateTime         @default(now())

  // Relations
  student    User         @relation(fields: [studentId], references: [id], onDelete: Cascade)
  booking    ClassBooking @relation(fields: [classId], references: [id], onDelete: Cascade)
  enrollment Enrollment   @relation(fields: [enrollmentId], references: [id], onDelete: Cascade)

  // Indexes
  @@unique([classId, studentId])
  @@index([classId])
  @@index([studentId])
  @@index([enrollmentId])
  @@map("class_attendances")
}

model TeacherAttendance {
  id        String   @id @default(cuid())
  classId   String
  teacherId String
  status    String   @default("PRESENT")
  timestamp DateTime @default(now())

  // Relations
  teacher User         @relation("TeacherAttendances", fields: [teacherId], references: [id], onDelete: Cascade)
  booking ClassBooking @relation(fields: [classId], references: [id], onDelete: Cascade)

  // Indexes
  @@unique([classId, teacherId])
  @@index([classId])
  @@index([teacherId])
  @@map("teacher_attendances")
}

enum AttendanceStatus {
  PRESENT
  ABSENT
}

// =============================================
// MODELOS DE CONFIGURACIÓN Y SOPORTE
// =============================================

model CalendarSettings {
  id                      String  @id @default(cuid())
  isGlobal                Boolean @default(true) // Siempre true para configuración global
  slotDuration            Int     @default(60) // Fijo en 60 minutos
  startHour               Float   @default(8)
  endHour                 Float   @default(16.5)
  maxBookingsPerStudent   Int     @default(3)
  bookingAdvanceNotice    Int     @default(24)
  cancellationWindow      Int     @default(12)
  rescheduleMinutes       Int     @default(60)
  maxReschedulesPerPeriod Int     @default(2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("calendar_settings")
}

// =============================================
// MODELOS DE TOKENS Y VERIFICACIÓN
// =============================================

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@map("password_reset_tokens")
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@map("verification_tokens")
}

// =============================================
// MODELOS COMERCIALES
// =============================================

model Category {
  id          String  @id @default(cuid())
  name        String
  slug        String  @unique
  description String?
  image       String?
  isActive    Boolean @default(true)
  sortOrder   Int     @default(0)

  // Relaciones
  products Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("categories")
}

model Feature {
  id          String  @id @default(cuid())
  name        String
  description String?
  icon        String?
  isActive    Boolean @default(true)

  // Relaciones
  planFeatures PlanFeature[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("features")
}

model Product {
  id           String   @id @default(cuid())
  name         String
  slug         String   @unique
  description  String?
  shortDesc    String?
  price        Float
  comparePrice Float?
  sku          String?  @unique
  image        String?
  images       String[]
  isActive     Boolean  @default(true)
  isDigital    Boolean  @default(true)
  stock        Int?
  categoryId   String?
  tags         String[] @default([])
  sortOrder    Int      @default(0) // Orden de aparición en la tienda

  // Campos para programación de publicación
  publishedAt  DateTime? // Fecha de inicio de publicación
  expiresAt    DateTime? // Fecha de fin de publicación

  // Campos para programación y cursos
  requiresScheduling Boolean @default(false)
  courseId           String?
  maxScheduleSlots   Int?    @default(1) // Máximo de horarios que puede reservar
  scheduleDuration   Int?    @default(60) // Duración en minutos

  // Campos para tipos de productos
  pricingType  ProductPricingType @default(SINGLE_PRICE) // Precio único o múltiples planes
  paymentType  ProductPaymentType @default(ONE_TIME)     // Pago único o recurrente

  // Campos para sistema de créditos
  creditPrice         Int?     // Precio en créditos (si acepta créditos)
  acceptsCredits      Boolean  @default(false) // Si acepta pago con créditos
  acceptsRealMoney    Boolean  @default(true) // Si acepta pago con dinero real

  // Relaciones
  category      Category?             @relation(fields: [categoryId], references: [id])
  course        Course?               @relation(fields: [courseId], references: [id])
  plans         Plan[]
  invoiceItems  InvoiceItem[]
  scheduleSlots ProductScheduleSlot[]
  purchases     ProductPurchase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([categoryId])
  @@index([courseId])
  @@map("products")
}

model Plan {
  id           String  @id @default(cuid())
  name         String
  slug         String  @unique
  description  String?
  // Precio base (legacy/default) - se mantiene para compatibilidad
  price        Float   @default(0)
  comparePrice Float?
  duration     Int // en días (duración del período de facturación)
  isActive     Boolean @default(true)
  isPopular    Boolean @default(false)
  sortOrder    Int     @default(0)
  productId    String?
  
  // Campos para integración con PayPal
  paypalSku    String? @unique // SKU configurado en PayPal para identificar este plan
  
  // Campos para planes con clases
  includesClasses     Boolean @default(false) // Si el plan incluye clases
  classesPerPeriod    Int?    // Cantidad de clases por período (ej: 8 clases por mes)
  classesPerWeek      Int?    // Frecuencia semanal (ej: 2 clases por semana)
  allowProration      Boolean @default(true) // Si permite prorateo al comprar a mitad de período
  autoRenewal         Boolean @default(true) // Si se renueva automáticamente
  billingCycle        String? // WEEKLY, MONTHLY, QUARTERLY, ANNUAL
  courseId            String? // Curso asociado al plan (opcional)

  // Campos para sistema de créditos
  creditPrice         Int?     // Precio en créditos (si acepta créditos)
  acceptsCredits      Boolean  @default(false) // Si acepta pago con créditos
  acceptsRealMoney    Boolean  @default(true) // Si acepta pago con dinero real

  // Relaciones
  product       Product?      @relation(fields: [productId], references: [id])
  course        Course?       @relation(fields: [courseId], references: [id])
  features      PlanFeature[]
  invoiceItems  InvoiceItem[]
  subscriptions Subscription[]
  coupons       Coupon[]      @relation("PlanCoupons")
  pricing       PlanPricing[] // Precios por idioma

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
  @@index([courseId])
  @@map("plans")
}

model PlanFeature {
  planId    String
  featureId String
  included  Boolean @default(true)
  value     String? // Para características con valores específicos

  // Relaciones
  plan    Plan    @relation(fields: [planId], references: [id], onDelete: Cascade)
  feature Feature @relation(fields: [featureId], references: [id], onDelete: Cascade)

  @@id([planId, featureId])
  @@map("plan_features")
}

model PlanPricing {
  id           String  @id @default(cuid())
  planId       String
  language     String  // Código de idioma: "en" (inglés), "es" (español), etc.
  price        Float   // Precio para este idioma
  comparePrice Float?  // Precio de comparación (tachado)
  currency     String  @default("USD") // Moneda del precio
  isActive     Boolean @default(true)
  
  // Campos opcionales para PayPal por idioma
  paypalSku    String? // SKU de PayPal específico para este idioma

  // Curso asociado a este idioma (determina a qué curso se inscribe el estudiante)
  courseId     String? // Curso específico para este idioma

  // Relaciones
  plan   Plan    @relation(fields: [planId], references: [id], onDelete: Cascade)
  course Course? @relation(fields: [courseId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([planId, language])
  @@index([planId])
  @@index([language])
  @@index([courseId])
  @@map("plan_pricing")
}

model Coupon {
  id          String     @id @default(cuid())
  code        String     @unique
  name        String?
  description String?
  type        CouponType @default(PERCENTAGE)
  value       Float // Porcentaje o cantidad fija
  minAmount   Float? // Monto mínimo para aplicar
  maxDiscount Float? // Descuento máximo (para porcentajes)
  usageLimit  Int? // Límite de usos total
  usageCount  Int        @default(0)
  userLimit   Int? // Límite por usuario
  isActive    Boolean    @default(true)
  startsAt    DateTime?
  expiresAt   DateTime?

  // Restricciones opcionales
  restrictedToUserId String? // Si se especifica, solo este usuario puede usar el cupón
  restrictedToPlanId String? // Si se especifica, solo aplica a este plan

  // Relaciones
  invoices       Invoice[]
  restrictedUser User? @relation("UserCoupons", fields: [restrictedToUserId], references: [id], onDelete: SetNull)
  restrictedPlan Plan? @relation("PlanCoupons", fields: [restrictedToPlanId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([restrictedToUserId])
  @@index([restrictedToPlanId])
  @@map("coupons")
}

model Invoice {
  id            String        @id @default(cuid())
  invoiceNumber String        @unique
  userId        String
  subtotal      Float
  discount      Float         @default(0)
  tax           Float         @default(0)
  total         Float
  status        InvoiceStatus @default(DRAFT)
  currency      String        @default("USD")
  couponId      String?
  notes         String?
  dueDate       DateTime?
  paidAt        DateTime?
  
  // Campos para PayPal
  paymentMethod String?       // 'paypal', 'creditCard', 'transfer'
  paypalOrderId String?       // ID de orden de PayPal
  paypalCaptureId String?     // ID de captura de PayPal
  paypalPayerEmail String?    // Email del pagador en PayPal

  // Campos para Niubiz
  niubizTransactionId String? // Token de transacción de Niubiz
  niubizOrderId       String? // ID de orden de Niubiz

  // Campos de dirección de facturación
  billingCountry  String? // País de facturación
  billingCity     String? // Ciudad de facturación
  billingAddress  String? // Dirección de facturación
  billingZipCode  String? // Código postal de facturación

  // Relaciones
  user                  User                    @relation(fields: [userId], references: [id])
  coupon                Coupon?                 @relation(fields: [couponId], references: [id])
  items                 InvoiceItem[]
  purchases             ProductPurchase[]
  creditPackagePurchases CreditPackagePurchase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([couponId])
  @@index([paypalOrderId])
  @@map("invoices")
}

model InvoiceItem {
  id        String  @id @default(cuid())
  invoiceId String
  productId String?
  planId    String?
  name      String // Nombre del producto/plan al momento de la compra
  price     Float
  quantity  Int     @default(1)
  total     Float

  // Relaciones
  invoice Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  product Product? @relation(fields: [productId], references: [id])
  plan    Plan?    @relation(fields: [planId], references: [id])

  @@index([invoiceId])
  @@index([productId])
  @@index([planId])
  @@map("invoice_items")
}

// =============================================
// ENUMS
// =============================================

enum UserRole {
  ADMIN
  TEACHER
  STUDENT
  EDITOR
  GUEST
}

enum UserStatus {
  ACTIVE
  INACTIVE
}

enum TeamBadge {
  SALES
  CUSTOMER_SERVICE
  ACADEMIC_COORDINATION
  TECHNICAL_SUPPORT
  ADMINISTRATION
  TEACHER
  STUDENT
}

enum ActivityStatus {
  ASSIGNED
  IN_PROGRESS
  COMPLETED
  EXPIRED
}

enum ActivityType {
  LISTENING
  READING
  SPEAKING
  VOCABULARY
  WRITING
  GRAMMAR
  PRONUNCIATION
  COMPREHENSION
  MULTIPLE_CHOICE
  FILL_IN_BLANK
  MATCHING
  ORDERING
  DICTATION
  TRANSLATION
  OTHER
}

enum ActivityStepType {
  INSTRUCTION
  QUESTION
  AUDIO
  RECORDING
  COMPLETION
}

enum BookingStatus {
  CANCELLED
  COMPLETED
  CONFIRMED
  NO_SHOW
  PENDING
}

enum EnrollmentStatus {
  PENDING   // Pre-inscripción (período no ha iniciado)
  ACTIVE    // Inscripción activa (período en curso)
  COMPLETED // Curso completado
  PAUSED    // Pausado temporalmente
  CANCELLED // Cancelado
}

enum EnrollmentType {
  AUTOMATIC // Inscripción automática al pagar y agendar clases
  MANUAL    // Inscripción manual desde el panel de administración (factura personalizada)
}

enum ContentType {
  // Tipos Estructurales
  TAB_GROUP
  TAB_ITEM
  CONTAINER

  // Tipos de Contenido
  RICH_TEXT
  IMAGE
  VIDEO
  AUDIO
  
  // Tipos Legacy / Específicos
  GRAMMAR_CARD
  LEVELED_TEXT
  THEMATIC_GLOSSARY
  DOWNLOADABLE_RESOURCE
  ACTIVITY
  PODCAST
  OTHER
}

enum ResourceType {
  GRAMMAR_GUIDE
  VOCABULARY_LIST
  EXERCISE_SHEET
  INFOGRAPHIC
  CONJUGATION_TABLE
  TEMPLATE
  OTHER
}

enum CouponType {
  PERCENTAGE
  FIXED_AMOUNT
}

enum ProductPricingType {
  SINGLE_PRICE    // Producto con un solo precio (franela, gorra, etc.)
  MULTIPLE_PLANS  // Producto con múltiples planes (programa regular con planes simple, regular, intensivo)
}

enum ProductPaymentType {
  ONE_TIME    // Pago único (merchandising, curso asíncrono)
  RECURRING   // Pago recurrente/suscripción (programa regular de inglés, español)
}

// =============================================
// MODELOS DE PROGRAMACIÓN Y RESERVAS
// =============================================

model ProductScheduleSlot {
  id        String   @id @default(cuid())
  productId String
  date      DateTime // Fecha y hora del slot
  isBooked  Boolean  @default(false)
  bookedBy  String? // ID del usuario que reservó

  // Relaciones
  product   Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  user      User?             @relation("ScheduleSlotBookings", fields: [bookedBy], references: [id])
  purchases ProductPurchase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([productId, date])
  @@index([productId])
  @@index([bookedBy])
  @@map("product_schedule_slots")
}

model ProductPurchase {
  id             String         @id @default(cuid())
  userId         String
  productId      String
  invoiceId      String
  scheduleSlotId String? // Slot reservado si aplica
  enrollmentId   String? // Inscripción creada automáticamente
  status         PurchaseStatus @default(PENDING)
  purchaseDate   DateTime       @default(now())
  scheduledDate  DateTime? // Fecha programada si aplica
  
  // Campos para selección de horario de clases
  selectedSchedule Json? // Horario seleccionado antes de la compra: {teacherId, dayOfWeek, startTime, endTime}[]
  proratedClasses  Int? // Número de clases prorrateadas calculadas
  proratedPrice    Float? // Precio prorrateado calculado

  // Relaciones
  user         User                 @relation(fields: [userId], references: [id])
  product      Product              @relation(fields: [productId], references: [id])
  invoice      Invoice              @relation(fields: [invoiceId], references: [id])
  scheduleSlot ProductScheduleSlot? @relation(fields: [scheduleSlotId], references: [id])
  enrollment   Enrollment?          @relation(fields: [enrollmentId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([productId])
  @@index([invoiceId])
  @@map("product_purchases")
}

enum PurchaseStatus {
  PENDING
  CONFIRMED
  SCHEDULED
  ENROLLED
  COMPLETED
  CANCELLED
}

model Subscription {
  id                String             @id @default(cuid())
  userId            String
  planId            String
  status            SubscriptionStatus @default(ACTIVE)
  startDate         DateTime           @default(now())
  endDate           DateTime?
  nextBillingDate   DateTime?
  cancelledAt       DateTime?
  cancelReason      String?
  
  // Campos de prorateo
  proratedPrice     Float? // Precio prorrateado si se compró a mitad de período
  proratedClasses   Int?   // Clases prorrateadas
  remainingClasses  Int?   // Clases restantes en el período actual

  // Campos de Niubiz / Recurrencia
  niubizCardToken   String?  // Token de la tarjeta guardada
  nextPaymentDate   DateTime? // Fecha del próximo intento de cobro (para lógica de reintentos)
  retryCount        Int       @default(0) // Contador de reintentos fallidos
  
  // Relaciones
  user              User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan              Plan               @relation(fields: [planId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@map("subscriptions")
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAUSED
  PAST_DUE
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

enum RewardType {
  EARNED_ACTIVITY // Puntos ganados por completar actividad
  EARNED_STREAK // Puntos ganados por racha
  EARNED_LEVEL // Puntos ganados por subir de nivel
  SPENT_LIVES // Puntos gastados en vidas
  SPENT_PREMIUM // Puntos gastados en lecciones premium
  SPENT_MERCHANDISE // Puntos gastados en mercancía
  SPENT_COUPON // Puntos gastados en cupones
}

enum CreditTransactionType {
  PURCHASE // Compra de paquete de créditos
  SPEND_PRODUCT // Gasto en producto
  SPEND_PLAN // Gasto en plan/suscripción
  SPEND_COURSE // Gasto en curso
  REFUND // Reembolso de créditos
  BONUS // Créditos de bonificación
  ADMIN_ADJUSTMENT // Ajuste manual por admin
  REWARD // Créditos ganados como recompensa
  EXPIRED // Créditos expirados
}

// =============================================
// MODELOS DE EXÁMENES
// =============================================

model Exam {
  id              String      @id @default(cuid())
  title           String
  description     String
  instructions    String?     // Instrucciones generales del examen
  timeLimit       Int?        // Tiempo límite total en minutos
  passingScore    Float       @default(70) // Puntaje mínimo para aprobar (%)
  maxAttempts     Int         @default(3) // Máximo número de intentos
  isBlocking      Boolean     @default(false) // Bloquea progreso si no se aprueba
  isOptional      Boolean     @default(false) // Es opcional para el curso
  isPublished     Boolean     @default(false)
  shuffleQuestions Boolean    @default(false) // Mezclar preguntas
  shuffleOptions  Boolean     @default(false) // Mezclar opciones
  showResults     Boolean     @default(true) // Mostrar resultados al finalizar
  allowReview     Boolean     @default(true) // Permitir revisar respuestas
  
  // Tipo de examen y acceso
  examType          ExamType  @default(COURSE_EXAM) // Tipo de examen
  isGuestAccessible Boolean   @default(false) // Permite acceso a usuarios GUEST sin inscripción
  targetLanguage    String?   // Idioma objetivo para placement tests (en, es, etc.)
  slug              String?   @unique // URL amigable para acceso directo (/test/[slug])
  isPublicAccess    Boolean   @default(false) // true = cualquiera con link, false = solo asignados
  
  // Configuración de Proctoring
  proctoringEnabled   Boolean @default(true) // Habilitar proctoring
  requireFullscreen   Boolean @default(true)  // Requerir pantalla completa
  blockCopyPaste      Boolean @default(true)  // Bloquear copiar/pegar
  blockRightClick     Boolean @default(true)  // Bloquear clic derecho
  maxWarnings         Int     @default(5)     // Máximo de advertencias antes de marcar
  
  createdById     String

  // Relaciones de contexto (opcional - puede estar en curso, módulo o lección)
  courseId        String?
  moduleId        String?
  lessonId        String?

  // Relaciones
  creator         User            @relation("ExamCreator", fields: [createdById], references: [id])
  course          Course?         @relation(fields: [courseId], references: [id])
  module          Module?         @relation(fields: [moduleId], references: [id])
  lesson          Lesson?         @relation(fields: [lessonId], references: [id])
  questions       ExamQuestion[]
  attempts        ExamAttempt[]
  assignments     ExamAssignment[]

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([courseId])
  @@index([moduleId])
  @@index([lessonId])
  @@index([createdById])
  @@map("exams")
}

model ExamQuestion {
  id              String          @id @default(cuid())
  examId          String
  type            QuestionType
  question        String          // Texto de la pregunta
  options         Json?           // Opciones para preguntas de opción múltiple
  correctAnswer   Json            // Respuesta(s) correcta(s)
  explanation     String?         // Explicación de la respuesta
  points          Float           @default(1) // Puntos que vale la pregunta
  order           Int             @default(0)
  difficulty      QuestionDifficulty @default(MEDIUM)
  tags            String[]        // Tags para categorización
  
  // Configuraciones específicas por tipo de pregunta
  caseSensitive   Boolean         @default(false) // Para preguntas de texto
  partialCredit   Boolean         @default(false) // Crédito parcial
  minLength       Int?            // Longitud mínima para ensayos
  maxLength       Int?            // Longitud máxima para ensayos

  // Configuraciones para ejercicios de listening
  audioUrl        String?         // URL del archivo de audio
  audioPosition   AudioPosition   @default(BEFORE_QUESTION) // Dónde mostrar el reproductor
  maxAudioPlays   Int?            // Número máximo de reproducciones (null = ilimitado)
  audioAutoplay   Boolean         @default(false) // Reproducir automáticamente
  audioPausable   Boolean         @default(false) // Permitir pausar el audio

  // Relaciones
  exam            Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)
  answers         ExamAnswer[]

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([examId])
  @@map("exam_questions")
}

model ExamAttempt {
  id              String          @id @default(cuid())
  examId          String
  userId          String
  attemptNumber   Int             // Número del intento (1, 2, 3...)
  status          AttemptStatus   @default(IN_PROGRESS)
  score           Float?          // Puntaje obtenido (%)
  totalPoints     Float?          // Puntos totales obtenidos
  maxPoints       Float?          // Puntos máximos posibles
  timeSpent       Int?            // Tiempo gastado en minutos
  startedAt       DateTime        @default(now())
  submittedAt     DateTime?
  reviewedAt      DateTime?       // Cuando fue revisado (para preguntas manuales)
  
  // Configuración del intento
  questionsOrder  Json?           // Orden de las preguntas si fueron mezcladas
  optionsOrder    Json?           // Orden de las opciones si fueron mezcladas
  
  // Resultado de placement test
  recommendedLevel String?        // Nivel recomendado (A1, A2, B1, B2, C1, C2) para placement tests
  resultEmailSent  Boolean        @default(false) // Si se envió email con resultados
  
  // Verificación pública
  verificationCode String?        // Código único para verificación pública
  allowPublicVerification Boolean @default(true) // Si permite verificación pública
  
  // Estado de navegación y flags
  currentQuestionIndex Int?       // Última pregunta vista por el estudiante
  flaggedQuestions    Json?       // Array de IDs de preguntas marcadas para revisar
  lastActivityAt      DateTime?   // Última actividad del estudiante en el examen
  
  // Relaciones
  exam            Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)
  user            User            @relation("ExamAttempts", fields: [userId], references: [id], onDelete: Cascade)
  answers         ExamAnswer[]
  proctorEvents   ProctorEvent[]

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@unique([examId, userId, attemptNumber])
  @@index([examId])
  @@index([userId])
  @@map("exam_attempts")
}

model ExamAnswer {
  id              String          @id @default(cuid())
  attemptId       String
  questionId      String
  answer          Json            // Respuesta dada por el estudiante
  isCorrect       Boolean?        // Si es correcta (null para preguntas manuales)
  pointsEarned    Float           @default(0) // Puntos ganados
  timeSpent       Int?            // Tiempo gastado en esta pregunta (segundos)
  
  // Para revisión manual
  needsReview     Boolean         @default(false)
  reviewedBy      String?         // ID del profesor que revisó
  reviewedAt      DateTime?
  feedback        String?         // Comentarios del profesor

  // Relaciones
  attempt         ExamAttempt     @relation(fields: [attemptId], references: [id], onDelete: Cascade)
  question        ExamQuestion    @relation(fields: [questionId], references: [id], onDelete: Cascade)
  reviewer        User?           @relation("ExamReviewer", fields: [reviewedBy], references: [id])

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@unique([attemptId, questionId])
  @@index([attemptId])
  @@index([questionId])
  @@map("exam_answers")
}

model ExamAssignment {
  id              String          @id @default(cuid())
  examId          String
  userId          String          // Estudiante asignado
  assignedBy      String          // Profesor que asignó
  dueDate         DateTime?       // Fecha límite
  instructions    String?         // Instrucciones específicas para este estudiante
  status          AssignmentStatus @default(ASSIGNED)
  
  // Relaciones
  exam            Exam            @relation(fields: [examId], references: [id], onDelete: Cascade)
  student         User            @relation("ExamAssignments", fields: [userId], references: [id], onDelete: Cascade)
  assignedByUser  User            @relation("ExamAssigner", fields: [assignedBy], references: [id])

  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@unique([examId, userId])
  @@index([examId])
  @@index([userId])
  @@index([assignedBy])
  @@map("exam_assignments")
}

// =============================================
// MODELOS DE VIDEOLLAMADAS Y COMUNICACIÓN
// =============================================

model VideoCall {
  id           String     @id @default(cuid())
  roomId       String     @unique
  teacherId    String
  studentId    String
  bookingId    String?    @unique // Vinculado a ClassBooking existente
  status       CallStatus @default(SCHEDULED)
  startTime    DateTime
  endTime      DateTime?
  duration     Int? // en minutos
  recordingUrl String? // URL de grabación JaaS (24h storage)

  // Relaciones
  teacher User          @relation("TeacherCalls", fields: [teacherId], references: [id])
  student User          @relation("StudentCalls", fields: [studentId], references: [id])
  booking ClassBooking? @relation(fields: [bookingId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([teacherId])
  @@index([studentId])
  @@index([bookingId])
  @@index([status])
  @@map("video_calls")
}

// Mensajes del chat de reuniones
model MeetingMessage {
  id        String   @id @default(cuid())
  bookingId String
  senderId  String
  content   String   @db.Text
  createdAt DateTime @default(now())

  // Relaciones
  booking ClassBooking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  sender  User         @relation("SentMeetingMessages", fields: [senderId], references: [id])

  @@index([bookingId])
  @@index([senderId])
  @@index([createdAt])
  @@map("meeting_messages")
}

// Whiteboard data for classroom sessions
model WhiteboardData {
  id        String   @id @default(cuid())
  bookingId String   @unique
  data      Json     // JSON with all drawing actions
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relaciones
  booking ClassBooking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@map("whiteboard_data")
}

// Modelos para chat flotante
model FloatingConversation {
  id            String    @id @default(cuid())
  title         String?
  isGroup       Boolean   @default(false)
  lastMessage   String?
  lastMessageAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relaciones
  participants ConversationParticipant[]
  messages     FloatingChatMessage[]

  @@map("floating_conversations")
}

model ConversationParticipant {
  id             String    @id @default(cuid())
  conversationId String
  userId         String
  joinedAt       DateTime  @default(now())
  lastReadAt     DateTime?

  isArchived     Boolean   @default(false)

  // Relaciones
  conversation FloatingConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@map("conversation_participants")
}

model FloatingChatMessage {
  id             String      @id @default(cuid())
  conversationId String
  senderId       String
  content        String
  type           MessageType @default(TEXT)
  metadata       Json?       // Metadata for files (url, name, size, type)
  timestamp      DateTime    @default(now())
  isRead         Boolean     @default(false)

  // Relaciones
  conversation FloatingConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User                 @relation("SentFloatingMessages", fields: [senderId], references: [id])

  @@index([conversationId])
  @@index([senderId])
  @@index([timestamp])
  @@map("floating_chat_messages")
}

enum CallStatus {
  SCHEDULED
  ACTIVE
  ENDED
  CANCELLED
  FAILED
}

enum MessageType {
  TEXT
  FILE
  SYSTEM
  EMOJI
}

// =============================================
// ENUMS DE EXÁMENES
// =============================================

enum QuestionType {
  MULTIPLE_CHOICE    // Opción múltiple
  TRUE_FALSE        // Verdadero/Falso
  SHORT_ANSWER      // Respuesta corta
  ESSAY            // Ensayo
  RECORDING        // Grabación de audio
  FILL_BLANK       // Llenar espacios en blanco
  MATCHING         // Emparejar
  ORDERING         // Ordenar elementos
  DRAG_DROP        // Arrastrar y soltar
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD
}

enum AttemptStatus {
  IN_PROGRESS      // En progreso
  SUBMITTED        // Enviado
  COMPLETED        // Completado y calificado
  EXPIRED          // Expirado por tiempo
  CANCELLED        // Cancelado
}

enum AssignmentStatus {
  ASSIGNED         // Asignado
  STARTED          // Iniciado
  SUBMITTED        // Enviado
  COMPLETED        // Completado
  OVERDUE          // Vencido
  CANCELLED        // Cancelado
}

enum ExamType {
  COURSE_EXAM      // Examen de curso normal
  PLACEMENT_TEST   // Test de clasificación
  DIAGNOSTIC       // Examen diagnóstico
  PRACTICE         // Examen de práctica libre
}

enum AudioPosition {
  BEFORE_QUESTION  // Antes del texto de la pregunta
  AFTER_QUESTION   // Después del texto de la pregunta
  BEFORE_OPTIONS   // Antes de las opciones (para opción múltiple)
  SECTION_TOP      // Al inicio de la sección (compartido)
}

// =============================================
// MODELOS DE ADMINISTRACIÓN DE ARCHIVOS
// =============================================

model FileAsset {
  id              String           @id @default(cuid())
  publicId        String           @unique // Cloudinary public_id
  fileName        String           // Original filename
  description     String?          // Optional description
  tags            String[]         @default([]) // Searchable tags
  category        FileCategory     @default(GENERAL)
  resourceType    FileResourceType // image, video, audio, raw
  format          String           // File format (jpg, mp4, pdf, etc.)
  size            Int              // File size in bytes
  width           Int?             // Width for images/videos
  height          Int?             // Height for images/videos
  duration        Int?             // Duration for videos/audio in seconds
  secureUrl       String           // Cloudinary secure URL
  url             String           // Cloudinary URL
  folder          String           // Cloudinary folder path
  uploadedBy      String           // User who uploaded the file
  isPublic        Boolean          @default(false) // Public access flag
  isActive        Boolean          @default(true) // Soft delete flag
  metadata        Json?            // Additional metadata (transformations, etc.)
  usageCount      Int              @default(0) // Track file usage
  lastAccessedAt  DateTime?
  expiresAt       DateTime?        // For temporary files
  
  // Relaciones
  uploader        User             @relation("FileUploader", fields: [uploadedBy], references: [id])
  transformations FileTransformation[]
  usageLogs       FileUsageLog[]

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([publicId])
  @@index([uploadedBy])
  @@index([resourceType])
  @@index([category])
  @@index([folder])
  @@index([isActive])
  @@index([createdAt])
  @@map("file_assets")
}

model FileTransformation {
  id              String           @id @default(cuid())
  fileAssetId     String
  name            String           // Transformation name (thumb, medium, large, etc.)
  transformation  Json             // Cloudinary transformation parameters
  generatedUrl    String           // URL of transformed file
  width           Int?
  height          Int?
  format          String?
  quality         Int?
  size            Int?             // Size of transformed file
  
  // Relación
  fileAsset       FileAsset        @relation(fields: [fileAssetId], references: [id], onDelete: Cascade)

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([fileAssetId])
  @@map("file_transformations")
}

model FileUsageLog {
  id              String           @id @default(cuid())
  fileAssetId     String
  userId          String?          // User who accessed the file
  action          UsageAction      // view, download, embed, transform
  context         String?          // Where the file was used (course, lesson, etc.)
  contextId       String?          // ID of the context entity
  ipAddress       String?
  userAgent       String?
  
  // Relaciones
  fileAsset       FileAsset        @relation(fields: [fileAssetId], references: [id], onDelete: Cascade)
  user            User?            @relation("FileUser", fields: [userId], references: [id])

  createdAt       DateTime         @default(now())

  @@index([fileAssetId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("file_usage_logs")
}

model FileFolder {
  id              String           @id @default(cuid())
  name            String
  path            String           @unique // Full path in Cloudinary
  parentId        String?          // Parent folder for nested structure
  description     String?
  isPublic        Boolean          @default(false)
  createdBy       String
  
  // Relaciones
  creator         User             @relation("FolderCreator", fields: [createdBy], references: [id])
  parent          FileFolder?      @relation("FolderHierarchy", fields: [parentId], references: [id])
  children        FileFolder[]     @relation("FolderHierarchy")

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([parentId])
  @@index([createdBy])
  @@map("file_folders")
}

// Enums para archivos
enum FileCategory {
  GENERAL         // Archivos generales
  COURSE_CONTENT  // Contenido de cursos
  LESSON_MATERIAL // Material de lecciones
  ASSIGNMENT      // Tareas y exámenes
  USER_AVATAR     // Avatares de usuarios
  BRANDING        // Archivos de marca
  DOCUMENTATION   // Documentación
  MEDIA           // Archivos multimedia
  TEMPLATE        // Plantillas
  BACKUP          // Archivos de respaldo
}

enum FileResourceType {
  IMAGE           // Imágenes
  VIDEO           // Videos
  AUDIO           // Archivos de audio
  DOCUMENT        // Documentos (PDF, DOC, XLS, etc.)
  RAW             // Otros archivos (ZIP, RAR, etc.)
}

enum UsageAction {
  VIEW            // Visualización
  DOWNLOAD        // Descarga
  EMBED           // Incrustado en contenido
  TRANSFORM       // Transformación aplicada
  SHARE           // Compartido
  DELETE          // Eliminado
}

// =============================================
// MODELOS DE BIBLIOTECA DE RECURSOS
// =============================================

model LibraryResource {
  id              String                @id @default(cuid())
  title           String
  slug            String                @unique
  description     String?
  excerpt         String?               // Resumen corto para listados
  type            LibraryResourceType
  status          LibraryResourceStatus @default(DRAFT)
  accessLevel     LibraryResourceAccess @default(PUBLIC) // Nivel de acceso: PUBLIC, PRIVATE (Go/Lingo), PREMIUM (Wow)
  
  // Contenido según el tipo
  content         String?               // Contenido HTML para artículos
  fileUrl         String?               // URL del archivo (PDF, imagen, audio, video)
  fileSize        Int?                  // Tamaño en bytes
  fileFormat      String?               // Extensión del archivo (pdf, mp3, mp4, etc.)
  thumbnailUrl    String?               // Imagen de portada/miniatura
  duration        Int?                  // Duración en segundos (para audio/video)
  
  // Metadatos
  language        String                @default("es") // Idioma del recurso
  level           String?               // Nivel de dificultad (A1, A2, B1, B2, C1, C2)
  tags            String[]              @default([])
  categoryId      String?
  authorId        String
  
  // Estadísticas
  viewCount       Int                   @default(0)
  downloadCount   Int                   @default(0)
  likeCount       Int                   @default(0)
  
  // SEO
  metaTitle       String?
  metaDescription String?
  
  // Fechas
  publishedAt     DateTime?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  // Relaciones
  category        LibraryCategory?      @relation(fields: [categoryId], references: [id])
  author          User                  @relation("LibraryAuthor", fields: [authorId], references: [id])
  userLikes       LibraryResourceLike[]
  userSaves       LibraryResourceSave[]

  @@index([type])
  @@index([status])
  @@index([accessLevel])
  @@index([categoryId])
  @@index([authorId])
  @@index([language])
  @@index([level])
  @@index([publishedAt])
  @@map("library_resources")
}

model LibraryCategory {
  id              String              @id @default(cuid())
  name            String
  slug            String              @unique
  description     String?
  icon            String?             // Nombre del icono (lucide)
  color           String?             // Color para UI
  sortOrder       Int                 @default(0)
  isActive        Boolean             @default(true)
  
  // Relaciones
  resources       LibraryResource[]

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@map("library_categories")
}

model LibraryResourceLike {
  id              String              @id @default(cuid())
  userId          String
  resourceId      String
  createdAt       DateTime            @default(now())

  // Relaciones
  user            User                @relation("LibraryLikes", fields: [userId], references: [id], onDelete: Cascade)
  resource        LibraryResource     @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  @@unique([userId, resourceId])
  @@index([userId])
  @@index([resourceId])
  @@map("library_resource_likes")
}

model LibraryResourceSave {
  id              String              @id @default(cuid())
  userId          String
  resourceId      String
  createdAt       DateTime            @default(now())

  // Relaciones
  user            User                @relation("LibrarySaves", fields: [userId], references: [id], onDelete: Cascade)
  resource        LibraryResource     @relation(fields: [resourceId], references: [id], onDelete: Cascade)

  @@unique([userId, resourceId])
  @@index([userId])
  @@index([resourceId])
  @@map("library_resource_saves")
}

enum LibraryResourceType {
  ARTICLE         // Artículo de blog redactado en la plataforma
  PDF             // Documento PDF
  IMAGE           // Imagen
  AUDIO           // Audio/Podcast
  VIDEO           // Video
  INFOGRAPHIC     // Infografía
  TEMPLATE        // Plantilla descargable
  EXERCISE_SHEET  // Hoja de ejercicios
  GRAMMAR_GUIDE   // Guía de gramática
  VOCABULARY_LIST // Lista de vocabulario
  OTHER           // Otros
}

enum LibraryResourceStatus {
  DRAFT           // Borrador
  PUBLISHED       // Publicado
  ARCHIVED        // Archivado
}

enum LibraryResourceAccess {
  PUBLIC          // Acceso público (todos pueden ver)
  PRIVATE         // Solo usuarios con suscripción activa (Go, Lingo, Wow)
  PREMIUM         // Solo usuarios con plan Wow
}


// =============================================
// MODELOS DE NOTIFICACIONES
// =============================================

model Notification {
  id          String             @id @default(cuid())
  userId      String             // Usuario que recibe la notificación
  type        NotificationType
  title       String
  message     String
  link        String?            // URL para navegar al hacer clic
  isRead      Boolean            @default(false)
  readAt      DateTime?
  metadata    Json?              // Datos adicionales (IDs relacionados, etc.)
  
  // Relaciones
  user        User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  @@index([userId])
  @@index([isRead])
  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}

enum NotificationType {
  // Inscripciones
  NEW_ENROLLMENT           // Nuevo estudiante inscrito (para profesor/admin)
  ENROLLMENT_CONFIRMED     // Inscripción confirmada (para estudiante)
  
  // Tareas y actividades
  TASK_ASSIGNED            // Tarea asignada (para estudiante)
  TASK_SUBMITTED           // Tarea enviada (para profesor)
  TASK_GRADED              // Tarea calificada (para estudiante)
  
  // Pagos y finanzas
  PAYMENT_RECEIVED         // Nuevo pago recibido (para admin)
  PAYMENT_CONFIRMED        // Pago confirmado (para estudiante)
  TEACHER_PAYMENT_CONFIRMED // Profesor confirmó su monto (para admin)
  
  // Clases
  CLASS_REMINDER           // Recordatorio de clase (para estudiante/profesor)
  CLASS_CANCELLED          // Clase cancelada
  CLASS_RESCHEDULED        // Clase reprogramada
  RECORDING_READY          // Grabación de clase lista (para estudiante)
  
  // Sistema
  SYSTEM_ANNOUNCEMENT      // Anuncio del sistema
  ACCOUNT_UPDATE           // Actualización de cuenta
}

// =============================================
// MODELOS DE ÓRDENES PENDIENTES (CHECKOUT)
// =============================================

model PendingOrder {
  id              String   @id @default(cuid())
  purchaseNumber  String   @unique
  userId          String?
  customerEmail   String?
  customerName    String?
  amount          Float
  currency        String   @default("USD")
  invoiceData     Json
  status          PendingOrderStatus @default(PENDING)
  expiresAt       DateTime
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([purchaseNumber])
  @@index([userId])
  @@index([status])
  @@index([expiresAt])
  @@map("pending_orders")
}

enum PendingOrderStatus {
  PENDING
  COMPLETED
  EXPIRED
  CANCELLED
}

// =============================================
// MODELOS DE GRABACIONES DE CLASES
// =============================================

model ClassRecording {
  id           String          @id @default(cuid())
  bookingId    String          // Permite múltiples grabaciones por booking
  egressId     String?         @unique // LiveKit egress ID - único para evitar duplicados
  roomId       String?
  roomName     String?
  
  // Información del archivo
  filename     String?
  fileUrl      String?         // URL pública o presigned URL
  fileSize     Int?            // Tamaño en bytes
  duration     Int?            // Duración en segundos
  
  // Metadatos de R2
  r2Key        String?         // Key en R2 bucket
  r2Bucket     String?         @default("lingowow-recordings")
  
  // Timestamps de la grabación
  startedAt    DateTime?
  endedAt      DateTime?
  
  // Estado de la grabación
  status       RecordingStatus @default(PROCESSING)
  
  // Número de segmento (para múltiples grabaciones en una clase)
  segmentNumber Int            @default(1)
  
  // Metadatos adicionales (JSON del webhook de LiveKit)
  metadata     Json?
  
  // Relaciones
  booking      ClassBooking    @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  @@index([bookingId])
  @@index([status])
  @@index([createdAt])
  @@map("class_recordings")
}

enum RecordingStatus {
  PROCESSING    // En proceso de grabación o procesamiento
  READY         // Lista para visualizar
  FAILED        // Error en la grabación
  ARCHIVED      // Archivada (no disponible temporalmente)
  DELETED       // Eliminada
}

// =============================================
// MODELOS DE NEWSLETTER
// =============================================

model NewsletterSubscription {
  id           String    @id @default(cuid())
  email        String    @unique
  userId       String?   // Opcional, puede ser suscriptor anónimo
  isSubscribed Boolean   @default(true)
  source       String?   // Fuente de suscripción: 'enrollment', 'landing', 'checkout', etc.
  
  // Historial de cambios
  subscribedAt   DateTime  @default(now())
  unsubscribedAt DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([userId])
  @@index([isSubscribed])
  @@map("newsletter_subscriptions")
}

// =============================================
// MODELOS PARA APP MÓVIL
// =============================================

model DeviceToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  platform  String   // 'ios' | 'android' | 'web'
  deviceId  String?
  isActive  Boolean  @default(true)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([token])
  @@map("device_tokens")
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  deviceId  String?
  expiresAt DateTime
  isRevoked Boolean  @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

// =============================================
// CONFIRMACIONES DE PAGO A PROFESORES
// =============================================

model TeacherPaymentConfirmation {
  id           String             @id @default(cuid())
  teacherId    String
  amount       Float
  periodStart  DateTime
  periodEnd    DateTime
  confirmedAt  DateTime           @default(now())
  hasProof     Boolean            @default(false)
  proofUrl     String?
  notes        String?
  status       ConfirmationStatus @default(PENDING)
  
  // Relaciones
  teacher      User               @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  
  @@unique([teacherId, periodStart, periodEnd])
  @@index([teacherId])
  @@index([confirmedAt])
  @@index([status])
  @@map("teacher_payment_confirmations")
}

enum ConfirmationStatus {
  PENDING
  APPROVED
  REJECTED
}
